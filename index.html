<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FSM Puzzle</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #1a1a1a;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(5, 50px);
      grid-template-rows: repeat(5, 50px);
      gap: 2px;
      margin: 20px;
    }
    .cell {
      width: 50px;
      height: 50px;
      background: #333;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .agent {
      background: lime;
    }
    .goal {
      background: gold;
    }
    #fsm-controls {
      display: flex;
      flex-direction: column;
      gap: 5px;
      max-width: 400px;
    }
    #fsm-controls textarea {
      width: 100%;
      height: 100px;
    }
    button {
      padding: 10px;
      background: #444;
      color: white;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <h1>ðŸ¤– FSM Puzzle</h1>
  <div id="grid"></div>
  <div id="fsm-controls">
    <label for="instructions">Define your FSM (e.g. "A:emptyâ†’right:B")</label>
    <textarea id="instructions"></textarea>
    <button id="run">Run FSM</button>
  </div>

  <script>
    const gridEl = document.getElementById('grid');
    const instructionsEl = document.getElementById('instructions');
    const runBtn = document.getElementById('run');

    const gridSize = 5;
    const grid = [];
    let agent = { x: 0, y: 0, state: 'A' };
    const goal = { x: 4, y: 4 };

    function createGrid() {
      gridEl.innerHTML = '';
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const div = document.createElement('div');
          div.classList.add('cell');
          if (x === agent.x && y === agent.y) div.classList.add('agent');
          if (x === goal.x && y === goal.y) div.classList.add('goal');
          gridEl.appendChild(div);
          grid.push({ x, y, el: div });
        }
      }
    }

    function getCell(x, y) {
      return grid.find(c => c.x === x && c.y === y);
    }

    function parseInstructions() {
      const lines = instructionsEl.value.split('\n');
      const fsm = {};
      for (const line of lines) {
        const match = line.match(/(\w+):(\w+)[â†’->](\w+):(\w+)/);
        if (match) {
          const [_, state, condition, direction, next] = match;
          fsm[state] = fsm[state] || [];
          fsm[state].push({ condition, direction, next });
        }
      }
      return fsm;
    }

    function getCondition(x, y) {
      if (x < 0 || y < 0 || x >= gridSize || y >= gridSize) return 'wall';
      if (x === goal.x && y === goal.y) return 'goal';
      return 'empty';
    }

    function move(dir) {
      const dx = dir === 'left' ? -1 : dir === 'right' ? 1 : 0;
      const dy = dir === 'up' ? -1 : dir === 'down' ? 1 : 0;
      const newX = agent.x + dx;
      const newY = agent.y + dy;
      if (getCondition(newX, newY) !== 'wall') {
        agent.x = newX;
        agent.y = newY;
      }
    }

    function step(fsm) {
      const rules = fsm[agent.state];
      if (!rules) return false;
      const condition = getCondition(agent.x, agent.y);
      for (const rule of rules) {
        if (rule.condition === condition || rule.condition === 'any') {
          move(rule.direction);
          agent.state = rule.next;
          return true;
        }
      }
      return false;
    }

    function runFSM() {
      const fsm = parseInstructions();
      let steps = 0;
      const interval = setInterval(() => {
        if (!step(fsm) || (agent.x === goal.x && agent.y === goal.y)) {
          clearInterval(interval);
          createGrid();
          if (agent.x === goal.x && agent.y === goal.y) {
            alert("ðŸŽ‰ Goal reached in state " + agent.state);
          } else {
            alert("ðŸ›‘ FSM halted.");
          }
        } else {
          createGrid();
        }
        if (++steps > 100) {
          clearInterval(interval);
          alert("âŒ FSM ran too long.");
        }
      }, 400);
    }

    runBtn.addEventListener('click', () => {
      agent = { x: 0, y: 0, state: 'A' };
      createGrid();
      runFSM();
    });

    createGrid();
  </script>
</body>
</html>
